'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var hsl = "fn getLuminosity(c: vec3<f32>) -> f32 {\r\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\r\n}\r\n\r\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\r\n  let d: f32 = lum - getLuminosity(c);\r\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\r\n\r\n  // clip back into legal range\r\n  let newLum: f32 = getLuminosity(newColor);\r\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\r\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\r\n\r\n  let t1: f32 = newLum / (newLum - cMin);\r\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\r\n\r\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\r\n\r\n  return finalColor;\r\n}\r\n\r\nfn getSaturation(c: vec3<f32>) -> f32 {\r\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\r\n}\r\n\r\n// Set saturation if color components are sorted in ascending order.\r\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\r\n  var result: vec3<f32>;\r\n  if (cSorted.z > cSorted.x) {\r\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\r\n    result = vec3<f32>(0.0, newY, s);\r\n  } else {\r\n    result = vec3<f32>(0.0, 0.0, 0.0);\r\n  }\r\n  return vec3<f32>(result.x, result.y, result.z);\r\n}\r\n\r\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\r\n    var result: vec3<f32> = c;\r\n\r\n    if (c.r <= c.g && c.r <= c.b) {\r\n        if (c.g <= c.b) {\r\n            result = setSaturationMinMidMax(result, s);\r\n        } else {\r\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\r\n            temp = setSaturationMinMidMax(temp, s);\r\n            result = vec3<f32>(temp.r, temp.b, temp.g);\r\n        }\r\n    } else if (c.g <= c.r && c.g <= c.b) {\r\n        if (c.r <= c.b) {\r\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\r\n            temp = setSaturationMinMidMax(temp, s);\r\n            result = vec3<f32>(temp.g, temp.r, temp.b);\r\n        } else {\r\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\r\n            temp = setSaturationMinMidMax(temp, s);\r\n            result = vec3<f32>(temp.g, temp.b, temp.r);\r\n        }\r\n    } else {\r\n        if (c.r <= c.g) {\r\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\r\n            temp = setSaturationMinMidMax(temp, s);\r\n            result = vec3<f32>(temp.b, temp.r, temp.g);\r\n        } else {\r\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\r\n            temp = setSaturationMinMidMax(temp, s);\r\n            result = vec3<f32>(temp.b, temp.g, temp.r);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}";

exports.default = hsl;
//# sourceMappingURL=hsl.wgsl.js.map
