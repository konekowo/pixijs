var source = "struct GlobalFilterUniforms {\r\n  uInputSize:vec4<f32>,\r\n  uInputPixel:vec4<f32>,\r\n  uInputClamp:vec4<f32>,\r\n  uOutputFrame:vec4<f32>,\r\n  uGlobalFrame:vec4<f32>,\r\n  uOutputTexture:vec4<f32>,  \r\n};\r\n\r\nstruct MaskUniforms {\r\n  uFilterMatrix:mat3x3<f32>,\r\n  uMaskClamp:vec4<f32>,\r\n  uAlpha:f32,\r\n};\r\n\r\n\r\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\r\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\r\n@group(0) @binding(2) var uSampler : sampler;\r\n\r\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\r\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\r\n\r\nstruct VSOutput {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) uv : vec2<f32>,\r\n    @location(1) filterUv : vec2<f32>,\r\n  };\r\n\r\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\r\n{\r\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\r\n\r\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\r\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\r\n\r\n    return vec4(position, 0.0, 1.0);\r\n}\r\n\r\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\r\n{\r\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\r\n}\r\n\r\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\r\n{\r\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \r\n}\r\n\r\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\r\n{\r\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\r\n}\r\n\r\nfn getSize() -> vec2<f32>\r\n{\r\n\r\n  \r\n  return gfu.uGlobalFrame.zw;\r\n}\r\n  \r\n@vertex\r\nfn mainVertex(\r\n  @location(0) aPosition : vec2<f32>, \r\n) -> VSOutput {\r\n  return VSOutput(\r\n   filterVertexPosition(aPosition),\r\n   filterTextureCoord(aPosition),\r\n   getFilterCoord(aPosition)\r\n  );\r\n}\r\n\r\n@fragment\r\nfn mainFragment(\r\n  @location(0) uv: vec2<f32>,\r\n  @location(1) filterUv: vec2<f32>,\r\n  @builtin(position) position: vec4<f32>\r\n) -> @location(0) vec4<f32> {\r\n\r\n    var maskClamp = filterUniforms.uMaskClamp;\r\n\r\n     var clip = step(3.5,\r\n        step(maskClamp.x, filterUv.x) +\r\n        step(maskClamp.y, filterUv.y) +\r\n        step(filterUv.x, maskClamp.z) +\r\n        step(filterUv.y, maskClamp.w));\r\n\r\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\r\n    var source = textureSample(uTexture, uSampler, uv);\r\n    \r\n    var npmAlpha = 0.0;\r\n\r\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\r\n\r\n    var a = (alphaMul * mask.r) * clip;\r\n\r\n    return vec4(source.rgb, source.a) * a;\r\n}";

export { source as default };
//# sourceMappingURL=mask.wgsl.mjs.map
